'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/* eslint-disable no-bitwise */

/**
 * @typedef {Object} Rgb
 * @property {number} red - The red component of the color (0 - 255)
 * @property {number} green - The green component of the color (0 - 255)
 * @property {number} blue - The blue component of the color (0 - 255)
 */

/**
 * @typedef {Object} Hsv
 * @property {number} hue - The hue of the color (0 - 360)
 * @property {number} saturation - The saturation the color (0.0 - 1.0)
 * @property {number} value - The value of the color (0.0 - 1.0)
 */

/**
 * Removes invalid characters and formats color hex to 6 characters
 * @param {string} colorHex The color value in hex format to sanitize
 */
function sanitizeHex(colorHex) {
  var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');

  if (sanitizedHex.length === 0) {
    sanitizedHex = '000000';
  } else if (sanitizedHex.length === 1) {
    sanitizedHex = sanitizedHex[0].repeat(6);
  } else if (sanitizedHex.length === 2) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(3)).concat(sanitizedHex[1].repeat(3));
  } else if (sanitizedHex.length >= 3 && sanitizedHex.length < 6) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(2)).concat(sanitizedHex[1].repeat(2)).concat(sanitizedHex[2].repeat(2));
  } else if (sanitizedHex.length > 6) {
    sanitizedHex = sanitizedHex.substr(0, 6);
  }

  return "#".concat(sanitizedHex);
}
/**
 * Converts a hex color string to its red, green, and blue component values
 * @param {string} colorHex The color value in hex format
 * @returns {Rgb} The RGB values for the color
 */

function hexToRgb(colorHex) {
  var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');

  if (sanitizedHex.length !== 6 && sanitizedHex.length !== 3) {
    throw new Error("Color should be either 3 or 6 characters in length - received a length of ".concat(sanitizedHex.length));
  }

  if (sanitizedHex.length === 3) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(2)).concat(sanitizedHex[1].repeat(2)).concat(sanitizedHex[2].repeat(2));
  }

  var rgb = parseInt(sanitizedHex, 16);

  if (Number.isNaN(rgb)) {
    throw new Error("Unable to parse hex color ".concat(colorHex));
  }

  var red = rgb >> 16 & 0xff;
  var green = rgb >> 8 & 0xff;
  var blue = rgb & 0xff;
  return {
    red: red,
    green: green,
    blue: blue
  };
}
/**
 * Takes given hue, saturation and value and returns the respective RGB values
 * @param {number} hue The hue of the color (0.0 - 1.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {Rgb} The RGB values for the color
 */

function hsvToRgb(hue, saturation, value) {
  // Bounds check
  if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1) {
    throw new Error('Invalid hue, saturation, or value - all values must be between 0 and 1');
  }

  var red = 0;
  var green = 0;
  var blue = 0;
  var huePercent = hue / 360;
  var i = Math.floor(huePercent * 6);
  var f = huePercent * 6 - i;
  var p = value * (1 - saturation);
  var q = value * (1 - f * saturation);
  var t = value * (1 - (1 - f) * saturation);

  switch (i % 6) {
    case 0:
      {
        red = value;
        green = t;
        blue = p;
        break;
      }

    case 1:
      {
        red = q;
        green = value;
        blue = p;
        break;
      }

    case 2:
      {
        red = p;
        green = value;
        blue = t;
        break;
      }

    case 3:
      {
        red = p;
        green = q;
        blue = value;
        break;
      }

    case 4:
      {
        red = t;
        green = p;
        blue = value;
        break;
      }

    case 5:
      {
        red = value;
        green = p;
        blue = q;
        break;
      }
  }

  red = Math.round(red * 255);
  green = Math.round(green * 255);
  blue = Math.round(blue * 255);
  return {
    red: red,
    green: green,
    blue: blue
  };
}
/**
 * Converts a hex color string to its hue, saturation, and value
 * @param {string} colorHex The color value in hex format
 * @returns {Hsv} The HSV values for the color
 */

function hexToHsv(colorHex) {
  // Hex validation handled by hexToRgb
  var _hexToRgb = hexToRgb(colorHex),
      red = _hexToRgb.red,
      green = _hexToRgb.green,
      blue = _hexToRgb.blue;

  var redPercent = red / 255;
  var greenPercent = green / 255;
  var bluePercent = blue / 255;
  var max = Math.max(redPercent, greenPercent, bluePercent);
  var min = Math.min(redPercent, greenPercent, bluePercent);
  var diff = max - min;
  var hue = 0;
  var saturation = max === 0 ? 0 : diff / max;
  var value = max;

  if (min === max) ; else {
    switch (max) {
      case redPercent:
        {
          hue = (greenPercent - bluePercent) / diff + (greenPercent < bluePercent ? 6 : 0);
          break;
        }

      case greenPercent:
        {
          hue = (bluePercent - redPercent) / diff + 2;
          break;
        }

      case bluePercent:
        {
          hue = (redPercent - greenPercent) / diff + 4;
          break;
        }
    }

    hue /= 6;
    hue *= 360;
  }

  return {
    hue: hue,
    saturation: saturation,
    value: value
  };
}
/**
 * Takes given red, green, and blue values and returns the hex color representation
 * @param {number} red The red component of the color (0 - 255)
 * @param {number} green The green component of the color (0 - 255)
 * @param {number} blue The blue component of the color (0 - 255)
 * @returns {string} The hex string representation of the color
 */

function rgbToHex(red, green, blue) {
  var rgb = blue | green << 8 | red << 16;
  return "#".concat((0x1000000 + rgb).toString(16).slice(1));
}
/**
 * Takes given hue, saturation and value and returns the hex color representation
 * @param {number} hue The hue of the color (0.0 - 1.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {string} The hex string representation of the color
 */

function hsvToHex(hue, saturation, value) {
  // Bounds check handled by hsvToRgb
  var _hsvToRgb = hsvToRgb(hue, saturation, value),
      red = _hsvToRgb.red,
      green = _hsvToRgb.green,
      blue = _hsvToRgb.blue;

  return rgbToHex(red, green, blue);
}

/**
 * @typedef {Object} Event
 * @property {Object} target The target element of the event
 */

/**
 * @typedef {Object} Element
 * @property {number} offsetLeft The left offset of the element
 * @property {number} offsetTop The top offset of the element
 * @property {Element} offsetParent The parent element the offset is relative to
 * @property {Element} parentElement The parent element
 */

/**
 * Check's if a referenced element is the target or parent of the target of an event
 * @param {Event} target The interaction event
 * @param {Object} ref A ref from a react useRef hook (object with a .current property)
 */
function isRefTargeted(evt, ref) {
  // Missing ref or event/target
  if (!ref || !ref.current || !evt || !evt.target) {
    return false;
  }

  var currentTarget = evt.target;

  do {
    if (currentTarget === ref.current) {
      return true;
    }

    currentTarget = currentTarget.parentElement;
  } while (currentTarget);

  return false;
}
/**
 * Gets the page relative top/left position of an element
 * @param {Element} element The DOM element to get the page position of
 */

function getPagePosition(element) {
  var left = element.offsetLeft;
  var top = element.offsetTop;
  var currentElement = element;

  while (currentElement.offsetParent) {
    currentElement = currentElement.offsetParent;
    left += currentElement.offsetLeft;
    top += currentElement.offsetTop;
  }

  return {
    left: left,
    top: top
  };
}
/**
 * Get the hue value from a given position on the hue slider
 * @param {number} x The x coordinate on the hue slider
 * @param {number} width The width of the hue slider
 */

function getHueFromPosition(x, width) {
  if (!width) {
    return 0;
  }

  var percentage = x / width;
  var hue = Math.max(Math.min(percentage, 1), 0) * 360;
  return hue;
}
/**
 * Get the saturation and value from a given position on the SV slider
 * @param {number} x The x coordinate on the SV selector
 * @param {number} y The y coordinate on the SV selector
 * @param {number} width The width of the SV selector
 * @param {number} height The height of the SV selector
 */

function getSaturationValueFromPosition(x, y, width, height) {
  var percentageX = !width ? 0 : x / width;
  var percentageY = !height ? 0 : 1 - y / height;
  var saturation = Math.max(Math.min(percentageX, 1), 0);
  var value = Math.max(Math.min(percentageY, 1), 0);
  return {
    saturation: saturation,
    value: value
  };
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".ReactColorPicker-module_react_color_picker__1OEfS {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_saturation_value__2AtC0 {\n  position: relative;\n  flex: 1 1 auto;\n  overflow: hidden;\n  margin-left: 11px;\n  margin-right: 11px;\n  margin-bottom: 10px;\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, #000000 100%), linear-gradient(to left, rgba(255, 255, 255, 0) 0%, #ffffff 100%);\n  background-color: #ffffff;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_saturation_value__2AtC0 .ReactColorPicker-module_saturation_value_picker__3aPab {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 28px;\n  height: 28px;\n  box-sizing: border-box;\n  border: 2px solid #ffffff;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.5);\n  border-radius: 14px;\n  cursor: pointer;\n  transform: translate(-50%, -50%);\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_hue_slider__1F8B5 {\n  position: relative;\n  height: 28px;\n  margin-left: 11px;\n  margin-right: 11px;\n  margin-bottom: 2px;\n  background-image: linear-gradient(to left, #ff0000 0%, #ff00ff 16.66%, #0000ff 33.33%, #00ffff 50%, #00ff00 66.66%, #ffff00 80.33%, #ff0000 100%);\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_hue_slider__1F8B5 .ReactColorPicker-module_hue_slider_picker__1bPFZ {\n  position: absolute;\n  top: -2px;\n  left: 0;\n  width: 18px;\n  height: 100%;\n  border: 2px solid #ffffff;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.5);\n  background-color: #ff0000;\n  border-radius: 11px;\n  cursor: pointer;\n  transform: translateX(-50%);\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ {\n  display: flex;\n  align-items: center;\n  margin-top: 10px;\n  margin-left: 11px;\n  margin-right: 11px;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ .ReactColorPicker-module_swatch__3kHFV {\n  width: 32px;\n  height: 32px;\n  margin-right: 10px;\n  border: 1px solid #ccc;\n}\n.ReactColorPicker-module_react_color_picker__1OEfS .ReactColorPicker-module_details__106p_ .ReactColorPicker-module_hex_value__10kKY {\n  width: 60px;\n  margin-left: 5px;\n}";
var styles = {"react_color_picker":"ReactColorPicker-module_react_color_picker__1OEfS","saturation_value":"ReactColorPicker-module_saturation_value__2AtC0","saturation_value_picker":"ReactColorPicker-module_saturation_value_picker__3aPab","hue_slider":"ReactColorPicker-module_hue_slider__1F8B5","hue_slider_picker":"ReactColorPicker-module_hue_slider_picker__1bPFZ","details":"ReactColorPicker-module_details__106p_","swatch":"ReactColorPicker-module_swatch__3kHFV","hex_value":"ReactColorPicker-module_hex_value__10kKY"};
styleInject(css_248z);

var ReactColorPicker = function ReactColorPicker(_ref) {
  var className = _ref.className,
      color = _ref.color,
      showHex = _ref.showHex,
      showSwatch = _ref.showSwatch,
      onChange = _ref.onChange,
      onInteractionStart = _ref.onInteractionStart,
      onInteractionEnd = _ref.onInteractionEnd,
      rest = _objectWithoutProperties(_ref, ["className", "color", "showHex", "showSwatch", "onChange", "onInteractionStart", "onInteractionEnd"]);

  var sanitizedColor = sanitizeHex(color || '#000000');

  var _useState = React.useState(sanitizedColor),
      _useState2 = _slicedToArray(_useState, 2),
      hex = _useState2[0],
      setHex = _useState2[1];

  var _useState3 = React.useState(hexToHsv(sanitizedColor)),
      _useState4 = _slicedToArray(_useState3, 2),
      hsv = _useState4[0],
      setHsv = _useState4[1]; // Used when editing the hex through the input


  var _useState5 = React.useState(hex),
      _useState6 = _slicedToArray(_useState5, 2),
      tempHex = _useState6[0],
      setTempHex = _useState6[1];

  var _useState7 = React.useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      isInteracting = _useState8[0],
      setIsInteracting = _useState8[1];

  var hsvRef = React.useRef(hsv);
  var hexRef = React.useRef(hex);
  var hueSliderRef = React.useRef();
  var svSliderRef = React.useRef(); // Set the hex and hsv states/refs with updated data

  var setColor = function setColor(updatedHex, updatedHsv) {
    hexRef.current = updatedHex;
    hsvRef.current = updatedHsv;
    setHex(updatedHex);
    setTempHex(updatedHex);
    setHsv(updatedHsv);
    onChange(updatedHex);
  }; // Helper to set the color when HSV change


  var setColorFromHsv = function setColorFromHsv(updatedHsv) {
    setColor(hsvToHex(updatedHsv.hue, updatedHsv.saturation, updatedHsv.value), updatedHsv);
  }; // Helper to set the color when hex changes


  var setColorFromHex = function setColorFromHex(updatedHex) {
    setColor(updatedHex, hexToHsv(updatedHex));
  }; // Event handler for hex input changes (on blur and enter pressed)


  var onHexChange = function onHexChange(value) {
    // Strip out invalid characters
    var sanitizedHex = sanitizeHex(value);
    setColorFromHex(sanitizedHex);
  }; // Update color when the passed value changes


  React.useEffect(function () {
    if (color !== hexRef.current) {
      var sanitizedHex = sanitizeHex(color || '#000000');
      setColorFromHex(sanitizedHex);
    }
  }, [color]); // Hookup cursor events to update the color selection

  React.useEffect(function () {
    var updateColor = function updateColor(evt) {
      // Update hue if targeted
      if (isRefTargeted(evt, hueSliderRef) && evt.buttons === 1) {
        var huePosition = getPagePosition(hueSliderRef.current);
        var x = evt.pageX - huePosition.left;
        var updatedHue = getHueFromPosition(x, hueSliderRef.current.clientWidth);
        setColorFromHsv(_objectSpread2(_objectSpread2({}, hsvRef.current), {}, {
          hue: updatedHue
        }));
      } // Update the saturation/value if targeted


      if (isRefTargeted(evt, svSliderRef) && evt.buttons === 1) {
        var svPosition = getPagePosition(svSliderRef.current);

        var _x = evt.pageX - svPosition.left;

        var y = evt.pageY - svPosition.top;
        var updatedSaturationValue = getSaturationValueFromPosition(_x, y, svSliderRef.current.clientWidth, svSliderRef.current.clientHeight);
        setColorFromHsv(_objectSpread2(_objectSpread2({}, hsvRef.current), updatedSaturationValue));
      }
    };

    var onMouseDown = function onMouseDown(evt) {
      if (isRefTargeted(evt, hueSliderRef) || isRefTargeted(evt, svSliderRef)) {
        setIsInteracting(true);
        onInteractionStart();
        updateColor(evt);
      }
    };

    var onMouseUp = function onMouseUp() {
      if (isInteracting) {
        setIsInteracting(false);
        onInteractionEnd();
      }
    };

    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', updateColor);
    document.addEventListener('mouseup', onMouseUp);
    return function () {
      document.removeEventListener('mousedown', onMouseDown);
      document.removeEventListener('mousemove', updateColor);
      document.removeEventListener('mouseup', onMouseUp);
    };
  }, [isInteracting]);
  var hue = hsv.hue,
      saturation = hsv.saturation,
      value = hsv.value; // Get the hex for the hue slider

  var hueColor = hsvToHex(hue, 1, 1);
  return /*#__PURE__*/React__default.createElement("div", _extends({
    className: "".concat(styles.react_color_picker).concat(className ? " ".concat(className) : '')
  }, rest), /*#__PURE__*/React__default.createElement("div", {
    className: styles.saturation_value,
    style: {
      backgroundColor: hueColor
    },
    ref: svSliderRef,
    title: "Saturation and Value"
  }, /*#__PURE__*/React__default.createElement("div", {
    className: styles.saturation_value_picker,
    style: {
      left: "".concat(saturation * 100, "%"),
      top: "".concat((1 - value) * 100, "%"),
      backgroundColor: hex
    }
  })), /*#__PURE__*/React__default.createElement("div", {
    className: styles.hue_slider,
    ref: hueSliderRef,
    title: "Hue"
  }, /*#__PURE__*/React__default.createElement("div", {
    className: styles.hue_slider_picker,
    style: {
      left: "".concat(hue / 360 * 100, "%"),
      backgroundColor: hueColor
    }
  })), (showHex || showSwatch) && /*#__PURE__*/React__default.createElement("div", {
    className: styles.details
  }, showSwatch && /*#__PURE__*/React__default.createElement("div", {
    className: styles.swatch,
    style: {
      backgroundColor: hex
    },
    title: "Swatch"
  }), showHex && /*#__PURE__*/React__default.createElement("label", null, /*#__PURE__*/React__default.createElement("span", null, "Hex:"), /*#__PURE__*/React__default.createElement("input", {
    className: styles.hex_value,
    value: tempHex,
    onChange: function onChange(evt) {
      return setTempHex(evt.target.value);
    },
    onBlur: function onBlur(evt) {
      return onHexChange(evt.target.value);
    },
    onKeyDown: function onKeyDown(evt) {
      if (evt.key === 'Enter') {
        onHexChange(evt.target.value);
      } else if (evt.key === 'Esc' || evt.key === 'Escape') {
        // eslint-disable-next-line no-param-reassign
        evt.target.value = hexRef.current;
        evt.target.blur();
      }
    }
  }))));
};

ReactColorPicker.propTypes = {
  className: PropTypes.string,
  color: PropTypes.string,
  showSwatch: PropTypes.bool,
  showHex: PropTypes.bool,
  onChange: PropTypes.func,
  onInteractionStart: PropTypes.func,
  onInteractionEnd: PropTypes.func
};
ReactColorPicker.defaultProps = {
  className: null,
  color: '#3cd6bf',
  showSwatch: true,
  showHex: true,
  onChange: function onChange() {},
  onInteractionStart: function onInteractionStart() {},
  onInteractionEnd: function onInteractionEnd() {}
};

module.exports = ReactColorPicker;
//# sourceMappingURL=index.js.map
