'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* eslint-disable no-bitwise */

/**
 * @typedef {Object} Rgb
 * @property {number} red - The red component of the color (0 - 255)
 * @property {number} green - The green component of the color (0 - 255)
 * @property {number} blue - The blue component of the color (0 - 255)
 */

/**
 * @typedef {Object} Hsv
 * @property {number} hue - The hue of the color (0 - 360)
 * @property {number} saturation - The saturation the color (0.0 - 1.0)
 * @property {number} value - The value of the color (0.0 - 1.0)
 */

/**
 * Removes invalid characters and formats color hex to 6 characters
 * @param {string} colorHex The color value in hex format to sanitize
 */
function sanitizeHex(colorHex) {
  var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');

  if (sanitizedHex.length === 0) {
    sanitizedHex = '000000';
  } else if (sanitizedHex.length === 1) {
    sanitizedHex = sanitizedHex[0].repeat(6);
  } else if (sanitizedHex.length === 2) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(3)).concat(sanitizedHex[1].repeat(3));
  } else if (sanitizedHex.length >= 3 && sanitizedHex.length < 6) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(2)).concat(sanitizedHex[1].repeat(2)).concat(sanitizedHex[2].repeat(2));
  } else if (sanitizedHex.length > 6) {
    sanitizedHex = sanitizedHex.substr(0, 6);
  }

  return "#".concat(sanitizedHex);
}
/**
 * Converts a hex color string to its red, green, and blue component values
 * @param {string} colorHex The color value in hex format
 * @returns {Rgb} The RGB values for the color
 */

function hexToRgb(colorHex) {
  var sanitizedHex = colorHex.replace(/[^a-fA-F0-9]/g, '');

  if (sanitizedHex.length !== 6 && sanitizedHex.length !== 3) {
    throw new Error("Color should be either 3 or 6 characters in length - received a length of ".concat(sanitizedHex.length));
  }

  if (sanitizedHex.length === 3) {
    sanitizedHex = "".concat(sanitizedHex[0].repeat(2)).concat(sanitizedHex[1].repeat(2)).concat(sanitizedHex[2].repeat(2));
  }

  var rgb = parseInt(sanitizedHex, 16);

  if (Number.isNaN(rgb)) {
    throw new Error("Unable to parse hex color ".concat(colorHex));
  }

  var red = rgb >> 16 & 0xff;
  var green = rgb >> 8 & 0xff;
  var blue = rgb & 0xff;
  return {
    red: red,
    green: green,
    blue: blue
  };
}
/**
 * Takes given hue, saturation and value and returns the respective RGB values
 * @param {number} hue The hue of the color (0.0 - 1.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {Rgb} The RGB values for the color
 */

function hsvToRgb(hue, saturation, value) {
  // Bounds check
  if (hue < 0 || hue > 360 || saturation < 0 || saturation > 1 || value < 0 || value > 1) {
    throw new Error('Invalid hue, saturation, or value - all values must be between 0 and 1');
  }

  var red = 0;
  var green = 0;
  var blue = 0;
  var huePercent = hue / 360;
  var i = Math.floor(huePercent * 6);
  var f = huePercent * 6 - i;
  var p = value * (1 - saturation);
  var q = value * (1 - f * saturation);
  var t = value * (1 - (1 - f) * saturation);

  switch (i % 6) {
    case 0:
      {
        red = value;
        green = t;
        blue = p;
        break;
      }

    case 1:
      {
        red = q;
        green = value;
        blue = p;
        break;
      }

    case 2:
      {
        red = p;
        green = value;
        blue = t;
        break;
      }

    case 3:
      {
        red = p;
        green = q;
        blue = value;
        break;
      }

    case 4:
      {
        red = t;
        green = p;
        blue = value;
        break;
      }

    case 5:
      {
        red = value;
        green = p;
        blue = q;
        break;
      }
  }

  red = Math.round(red * 255);
  green = Math.round(green * 255);
  blue = Math.round(blue * 255);
  return {
    red: red,
    green: green,
    blue: blue
  };
}
/**
 * Converts a hex color string to its hue, saturation, and value
 * @param {string} colorHex The color value in hex format
 * @returns {Hsv} The HSV values for the color
 */

function hexToHsv(colorHex) {
  // Hex validation handled by hexToRgb
  var _hexToRgb = hexToRgb(colorHex),
      red = _hexToRgb.red,
      green = _hexToRgb.green,
      blue = _hexToRgb.blue;

  var redPercent = red / 255;
  var greenPercent = green / 255;
  var bluePercent = blue / 255;
  var max = Math.max(redPercent, greenPercent, bluePercent);
  var min = Math.min(redPercent, greenPercent, bluePercent);
  var diff = max - min;
  var hue = 0;
  var saturation = max === 0 ? 0 : diff / max;
  var value = max;

  if (min === max) ; else {
    switch (max) {
      case redPercent:
        {
          hue = (greenPercent - bluePercent) / diff + (greenPercent < bluePercent ? 6 : 0);
          break;
        }

      case greenPercent:
        {
          hue = (bluePercent - redPercent) / diff + 2;
          break;
        }

      case bluePercent:
        {
          hue = (redPercent - greenPercent) / diff + 4;
          break;
        }
    }

    hue /= 6;
    hue *= 360;
  }

  return {
    hue: hue,
    saturation: saturation,
    value: value
  };
}
/**
 * Takes given red, green, and blue values and returns the hex color representation
 * @param {number} red The red component of the color (0 - 255)
 * @param {number} green The green component of the color (0 - 255)
 * @param {number} blue The blue component of the color (0 - 255)
 * @returns {string} The hex string representation of the color
 */

function rgbToHex(red, green, blue) {
  var rgb = blue | green << 8 | red << 16;
  return "#".concat((0x1000000 + rgb).toString(16).slice(1));
}
/**
 * Takes given hue, saturation and value and returns the hex color representation
 * @param {number} hue The hue of the color (0.0 - 1.0)
 * @param {number} saturation The saturation of the color (0.0 - 1.0)
 * @param {number} value The value of the color (0.0 - 1.0)
 * @returns {string} The hex string representation of the color
 */

function hsvToHex(hue, saturation, value) {
  // Bounds check handled by hsvToRgb
  var _hsvToRgb = hsvToRgb(hue, saturation, value),
      red = _hsvToRgb.red,
      green = _hsvToRgb.green,
      blue = _hsvToRgb.blue;

  return rgbToHex(red, green, blue);
}
/**
 * Get the perceived brightness of a given color
 * See: https://www.w3.org/TR/AERT/#color-contrast
 * @param {number} red The red component of the color (0 - 255)
 * @param {number} green The green component of the color (0 - 255)
 * @param {number} blue The blue component of the color (0 - 255)
 * @returns {number} The perceived brightness of the color (0.0 - 1.0)
 */

function getPerceivedLuminance(red, green, blue) {
  return (red * 0.299 + green * 0.587 + blue * 0.114) / 255;
}

exports.getPerceivedLuminance = getPerceivedLuminance;
exports.hexToHsv = hexToHsv;
exports.hexToRgb = hexToRgb;
exports.hsvToHex = hsvToHex;
exports.hsvToRgb = hsvToRgb;
exports.rgbToHex = rgbToHex;
exports.sanitizeHex = sanitizeHex;
//# sourceMappingURL=colorutils.js.map
